const mongoose = require('mongoose');

const PurchaseSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    items: [
      {
        itemType: {
          type: String,
          enum: ['course', 'bundle'],
          required: true,
        },
        item: {
          type: mongoose.Schema.Types.ObjectId,
          required: true,
          refPath: 'items.itemTypeModel',
        },
        itemTypeModel: {
          type: String,
          enum: ['Course', 'BundleCourse'],
          required: true,
        },
        title: {
          type: String,
          required: true,
        },
        price: {
          type: Number,
          required: true,
          min: 0,
        },
        quantity: {
          type: Number,
          default: 1,
          min: 1,
          max: 1, // Only allow 1 quantity per course/bundle
        },
      },
    ],
    subtotal: {
      type: Number,
      required: true,
      min: 0,
    },
    tax: {
      type: Number,
      required: true,
      min: 0,
      default: 0,
    },
    total: {
      type: Number,
      required: true,
      min: 0,
    },
    // Promo Code fields
    appliedPromoCode: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'PromoCode',
      default: null,
    },
    discountAmount: {
      type: Number,
      default: 0,
      min: 0,
    },
    originalAmount: {
      type: Number,
      default: null, // Original amount before discount
    },
    promoCodeUsed: {
      type: String,
      default: null, // The actual promo code string used
    },
    currency: {
      type: String,
      default: 'EGP',
    },
    paymentMethod: {
      type: String,
      enum: ['credit_card', 'paypal', 'stripe', 'bank_transfer', 'paymob'],
      default: 'paymob',
    },
    paymentStatus: {
      type: String,
      enum: [
        'pending',
        'processing',
        'completed',
        'failed',
        'cancelled',
        'refunded',
      ],
      default: 'pending',
    },
    paymentGateway: {
      type: String,
      enum: ['stripe', 'paypal', 'razorpay', 'square'],
      default: 'stripe',
    },
    paymentIntentId: {
      type: String,
      default: '',
    },
    paymentGatewayResponse: {
      type: mongoose.Schema.Types.Mixed,
      default: {},
    },
    billingAddress: {
      firstName: {
        type: String,
        required: true,
      },
      lastName: {
        type: String,
        required: true,
      },
      email: {
        type: String,
        required: true,
      },
      phone: {
        type: String,
        required: true,
      },
      address: {
        type: String,
        required: true,
      },
      city: {
        type: String,
        required: true,
      },
      state: {
        type: String,
        required: true,
      },
      zipCode: {
        type: String,
        required: true,
      },
      country: {
        type: String,
        required: true,
      },
    },
    status: {
      type: String,
      enum: [
        'pending',
        'processing',
        'completed',
        'failed',
        'cancelled',
        'refunded',
      ],
      default: 'pending',
    },
    orderNumber: {
      type: String,
      unique: true,
      required: false, // Will be generated by pre-save hook
      validate: {
        validator: function (v) {
          return v && v.length > 0;
        },
        message: 'Order number is required',
      },
    },
    notes: {
      type: String,
      maxlength: 1000,
    },
    refundedAt: {
      type: Date,
    },
    refundAmount: {
      type: Number,
      min: 0,
    },
    refundReason: {
      type: String,
    },
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Generate order number before saving
PurchaseSchema.pre('save', async function (next) {
  if (this.isNew && !this.orderNumber) {
    let orderNumber;
    let isUnique = false;
    let attempts = 0;
    const maxAttempts = 10;

    while (!isUnique && attempts < maxAttempts) {
      const timestamp = Date.now().toString().slice(-6);
      const random = Math.floor(Math.random() * 1000)
        .toString()
        .padStart(3, '0');
      orderNumber = `ORD-${timestamp}-${random}`;

      try {
        const existingPurchase = await this.constructor.findOne({
          orderNumber,
        });
        if (!existingPurchase) {
          isUnique = true;
        }
      } catch (error) {
        console.error('Error checking order number uniqueness:', error);
        // If there's an error, just use the generated number
        isUnique = true;
      }

      attempts++;
    }

    // Fallback if we couldn't find a unique number
    if (!isUnique) {
      orderNumber = `ORD-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
    }

    this.orderNumber = orderNumber;
  }
  next();
});

// Virtual for purchase status display
PurchaseSchema.virtual('statusDisplay').get(function () {
  const statusMap = {
    pending: 'Pending Payment',
    processing: 'Processing',
    completed: 'Completed',
    failed: 'Payment Failed',
    cancelled: 'Cancelled',
    refunded: 'Refunded',
  };
  return statusMap[this.status] || this.status;
});

// Virtual for payment status display
PurchaseSchema.virtual('paymentStatusDisplay').get(function () {
  const statusMap = {
    pending: 'Pending',
    processing: 'Processing',
    completed: 'Completed',
    failed: 'Failed',
    cancelled: 'Cancelled',
    refunded: 'Refunded',
  };
  return statusMap[this.paymentStatus] || this.paymentStatus;
});

// Virtuals for analytics
PurchaseSchema.virtual('itemCount').get(function () {
  return Array.isArray(this.items) ? this.items.length : 0;
});

PurchaseSchema.virtual('isRefunded').get(function () {
  return this.status === 'refunded' || this.paymentStatus === 'refunded';
});

// Instance method to calculate totals
PurchaseSchema.methods.calculateTotals = function () {
  this.subtotal = this.items.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0
  );
  this.tax = this.subtotal * 0.1; // 10% tax
  this.total = this.subtotal + this.tax;
  return this;
};

// Instance method to mark as completed
PurchaseSchema.methods.markAsCompleted = async function () {
  this.status = 'completed';
  this.paymentStatus = 'completed';
  return await this.save();
};

// Instance method to mark as failed
PurchaseSchema.methods.markAsFailed = async function () {
  this.status = 'failed';
  this.paymentStatus = 'failed';
  return await this.save();
};

// Static method to get user purchases
PurchaseSchema.statics.getUserPurchases = function (userId, options = {}) {
  const query = { user: userId };

  if (options.status) {
    query.status = options.status;
  }

  if (options.dateFrom || options.dateTo) {
    query.createdAt = {};
    if (options.dateFrom) query.createdAt.$gte = new Date(options.dateFrom);
    if (options.dateTo) query.createdAt.$lte = new Date(options.dateTo);
  }

  return this.find(query).populate('items.item').sort({ createdAt: -1 });
};

// Static method to get purchase statistics
PurchaseSchema.statics.getPurchaseStats = async function () {
  const stats = await this.aggregate([
    {
      $group: {
        _id: null,
        totalPurchases: { $sum: 1 },
        totalRevenue: { $sum: '$total' },
        completedPurchases: {
          $sum: {
            $cond: [{ $eq: ['$status', 'completed'] }, 1, 0],
          },
        },
        pendingPurchases: {
          $sum: {
            $cond: [{ $eq: ['$status', 'pending'] }, 1, 0],
          },
        },
        failedPurchases: {
          $sum: {
            $cond: [{ $eq: ['$status', 'failed'] }, 1, 0],
          },
        },
        avgOrderValue: { $avg: '$total' },
      },
    },
  ]);

  return (
    stats[0] || {
      totalPurchases: 0,
      totalRevenue: 0,
      completedPurchases: 0,
      pendingPurchases: 0,
      failedPurchases: 0,
      avgOrderValue: 0,
    }
  );
};

module.exports = mongoose.model('Purchase', PurchaseSchema);
